{"meta":{"title":"ke_xx","subtitle":null,"description":"Blog","author":"ke_xx","url":"https://ic-.gihub.io"},"pages":[{"title":"分类","date":"2017-02-20T10:38:28.000Z","updated":"2017-02-21T02:28:25.000Z","comments":true,"path":"categories/index.html","permalink":"https://ic-.gihub.io/categories/index.html","excerpt":"","text":""},{"title":"标签云","date":"2014-12-22T04:39:04.000Z","updated":"2017-02-21T02:28:25.000Z","comments":false,"path":"tags/index.html","permalink":"https://ic-.gihub.io/tags/index.html","excerpt":"","text":""},{"title":"record","date":"2017-02-16T03:32:13.000Z","updated":"2017-02-16T03:33:05.000Z","comments":true,"path":"record/index.html","permalink":"https://ic-.gihub.io/record/index.html","excerpt":"","text":"22222"},{"title":"archive","date":"2017-02-16T03:32:03.000Z","updated":"2017-02-16T03:33:05.000Z","comments":true,"path":"archive/index.html","permalink":"https://ic-.gihub.io/archive/index.html","excerpt":"","text":"1111"}],"posts":[{"title":"XSS和CSRF攻击","slug":"safety","date":"2017-04-05T03:32:59.000Z","updated":"2017-04-05T07:36:32.000Z","comments":true,"path":"2017/04/05/safety/","link":"","permalink":"https://ic-.gihub.io/2017/04/05/safety/","excerpt":"","text":"XSS和CSRF跨站攻击 不攻击服务器攻击用户信息 XSS 预期之外的js脚本输入 过滤用户输入，用户的输入是不可信的 对一些关键字和特殊字符进行过滤或 URL、HTML 编码，”&lt;&gt;?”或”script，javascript”； CSRF 跨站请求伪造 创建一个唯一的令牌（Token），将其存在服务端的session中及客户端的cookie中，对任何请求，都检查二者是否一致。 token不对让他去登陆","categories":[{"name":"js","slug":"js","permalink":"https://ic-.gihub.io/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://ic-.gihub.io/tags/js/"}]},{"title":"字符串 string","slug":"string","date":"2017-03-30T08:36:17.000Z","updated":"2017-03-30T12:37:05.000Z","comments":true,"path":"2017/03/30/string/","link":"","permalink":"https://ic-.gihub.io/2017/03/30/string/","excerpt":"字符串相关内容查找方法 charAt(n) n &gt; len //空字符串 charCodeAt(n) //unicode编码 n &gt; len //NaN fromCharAt(unicode1, unicode2, …) //跟进字符串编码创建字符串 返回字符串 位置方法 indexOf() lastIndexOf() url获取参数 split(url.lastIndexOf(‘?’)) 找到返回位置 未找到返回 -1","text":"字符串相关内容查找方法 charAt(n) n &gt; len //空字符串 charCodeAt(n) //unicode编码 n &gt; len //NaN fromCharAt(unicode1, unicode2, …) //跟进字符串编码创建字符串 返回字符串 位置方法 indexOf() lastIndexOf() url获取参数 split(url.lastIndexOf(‘?’)) 找到返回位置 未找到返回 -1 匹配方法 match 一个或者多个匹配 返回匹配数组 有g 多个匹配 所有匹配的子串 没有派生属性 没有子表达式匹配 无g 单个匹配 匹配文本 其他子表达式匹配 属性 input 调用改方法的字符串对象 index 匹配文本的起始位置 lastIndex 匹配文本的结束位置 没找到返回null search 找到返回位置 未找到返回 -1 replace $$ //$ $&amp; //整个模式的子字符串 就是匹配的内容 $’ //匹配字符串之前的字符串 $` //匹配字符串之后的字符串 $0-9 //匹配第n个捕获组 function(arguments){} 12345678910var str = 'aabbccddee';str.replace(/(bb)(cc)/g, function()&#123; console.log(arguments); // 0 : bbcc // 1 : bb // 2 : cc // 3 : 2 // 4 : aabbcxdsee //&#125;) split 分割符号 长度 操作方法 concat string.concat(values, ….) slice(start, end) substring(start, end) substr(start, end) trim() trimLeft() trimRight 编码方法 escape() unescape() encodeURI() decodeURI() URL标识不会被编码 如： htt:// =&gt; http:// encodeURIComponent() decodeURIComponent() 对整个URI都编码了 如： htt:// =&gt; http%3A// 转换方法 toLowerCase() toUpperCase()","categories":[{"name":"js","slug":"js","permalink":"https://ic-.gihub.io/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://ic-.gihub.io/tags/js/"},{"name":"string","slug":"string","permalink":"https://ic-.gihub.io/tags/string/"}]},{"title":"函数基础","slug":"function","date":"2017-03-30T06:41:25.000Z","updated":"2017-04-05T15:55:42.000Z","comments":true,"path":"2017/03/30/function/","link":"","permalink":"https://ic-.gihub.io/2017/03/30/function/","excerpt":"函数基础知识函数定义123function fn()&#123;&#125;var fn = function()&#123;&#125;var fn = new Function(arg1, arg2, \"console.log(arg1,arg2)\" ) 调用方法 直接调用 fn() 链接中 事件中 递归","text":"函数基础知识函数定义123function fn()&#123;&#125;var fn = function()&#123;&#125;var fn = new Function(arg1, arg2, \"console.log(arg1,arg2)\" ) 调用方法 直接调用 fn() 链接中 事件中 递归 123456789101112document.onLoad = function()&#123; fn()&#125;function aa(n) &#123; if(n &lt; 10)&#123; n++; aa(n) &#125;else&#123; return n &#125;&#125; 方法 fn.apply(obj, [args]) fn.call(obj, arg1, arg2, …) fn.toString() arguments 对象 实参参数列表 有下标属性 类数组 属性 arguments.length arguments.callee //返回当前正在指向对象 arguments.caler //返回调用当前正执行函数的 函数 函数参数 形参 定义函数时使用的参数 实参 调用函数时使用的参数 形参 &gt; 实参 形参undefined 实参 &gt; 形参 忽略 指针标识 this 指向当前对象 callee 指向参数集合所属函数 prototype 函数的原型对象 constructor 函数的构造函数","categories":[{"name":"js","slug":"js","permalink":"https://ic-.gihub.io/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://ic-.gihub.io/tags/js/"}]},{"title":"Dom 操作","slug":"dom","date":"2017-03-30T06:28:46.000Z","updated":"2017-03-30T07:08:47.000Z","comments":true,"path":"2017/03/30/dom/","link":"","permalink":"https://ic-.gihub.io/2017/03/30/dom/","excerpt":"Dom 基本操作获取节点 document getElementById getElementsByTagName getElementsByName 节点指针 parentNode childNodes previousSibling nextSibling firstChild lastChild","text":"Dom 基本操作获取节点 document getElementById getElementsByTagName getElementsByName 节点指针 parentNode childNodes previousSibling nextSibling firstChild lastChild 节点操作创建节点 document createElement createAttribute createTextNode插入节点 appendChild insertBefore替换节点 replaceChild复制节点 cloneChild(true/false) true 有子节点 false 无子节点删除节点 removeChild属性操作 getAttribute setAttribute removeAttribute","categories":[{"name":"js","slug":"js","permalink":"https://ic-.gihub.io/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://ic-.gihub.io/tags/js/"},{"name":"dom","slug":"dom","permalink":"https://ic-.gihub.io/tags/dom/"}]},{"title":"排序去重","slug":"arrSort","date":"2017-03-29T12:26:40.000Z","updated":"2017-03-30T07:08:47.000Z","comments":true,"path":"2017/03/29/arrSort/","link":"","permalink":"https://ic-.gihub.io/2017/03/29/arrSort/","excerpt":"数组去重和排序去重12345678910111213Array.prototype.unique=function() &#123; var arr = []; this.sort(); for(var i = 0, len = this.length; i &lt; len; i++)&#123; if(this[i] != this[i+1])&#123; arr.push(this[i]) &#125; &#125; return arr;&#125;var arr = [1, 1, 2, 4, 5, 3, 4, 5, 2];console.log(arr.unique()) //[1, 2, 3, 4, 5]","text":"数组去重和排序去重12345678910111213Array.prototype.unique=function() &#123; var arr = []; this.sort(); for(var i = 0, len = this.length; i &lt; len; i++)&#123; if(this[i] != this[i+1])&#123; arr.push(this[i]) &#125; &#125; return arr;&#125;var arr = [1, 1, 2, 4, 5, 3, 4, 5, 2];console.log(arr.unique()) //[1, 2, 3, 4, 5] 排序sort12345arr.sort((x1, x2) =&gt; &#123; // return -1 // &lt;0 [x1, x2] // return 1 // &gt;0 [x2, x1] // return 0 // =0 [x1, x2]&#125;) 冒泡排序 每次从第一个开始冒泡 是否交换位置 0-1 是否交换 1-2 是否交换 2-3 是否交换 。。。 arr[-1] //undefined &lt; || &gt; number false 最后一个不冒泡 数组被取值会先内部执行 var arr = [1, console.log(11)][0] arr; //11 1 12345678910111213function bubbleSort(arr)&#123; var len = arr.length; for( var i = 0; i &lt; len; i++)&#123; for(var j = 0; j &lt; len-1; j++)&#123; if(arr[j] &lt; arr[j-1])&#123; arr[j] = [arr[j-1], arr[j-1]=arr[j]][0] &#125; if(arr[j] == arr[j-1])&#123; arr.splice(j, 1) &#125; &#125; &#125;&#125; 选择排序 选择个元素min 对比每个元素 找到比min小的元素 交互i和新的最小的min位置 123456789101112131415function selectSort(arr)&#123; var len = arr.length; var min; for(var i = 0; i &lt; len; i++)&#123; min = i; for(var j =i; j &lt; len; j++)&#123; if(arr[min] &gt; arr[j])&#123; min = j; &#125; &#125; if(min != i)&#123; arr[i] = [arr[min], arr[min] = arr[i]][0] &#125; &#125;&#125; 快速排序 取一个中间数 num 与num比较大小 把数组切分成左右2组 递归继续排序 合并数组 123456789101112131415function quickSort(arr)&#123; var len = arr.length; if(len &lt;= 1)&#123; return arr &#125; var num = arr[Math.floor(len/2)]; var left = []; var right = []; for(var i = 0; i &lt; arr.length; i++)&#123; if(arr[i] == num) continue; arr[i] &lt; num ? left.push(arr[i]) : right.push(arr[i]) &#125; return quickSort(left).concat(num, quickSort(right))&#125;","categories":[{"name":"js","slug":"js","permalink":"https://ic-.gihub.io/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://ic-.gihub.io/tags/js/"},{"name":"sort","slug":"sort","permalink":"https://ic-.gihub.io/tags/sort/"}]},{"title":"js设计模式","slug":"design","date":"2017-03-29T03:18:44.000Z","updated":"2017-03-29T12:25:51.000Z","comments":true,"path":"2017/03/29/design/","link":"","permalink":"https://ic-.gihub.io/2017/03/29/design/","excerpt":"设计模式 让系统代码可重用 可扩展 可解耦 更容易 被理解 且保证代码的可靠性 原则 开闭原则：对扩展开发 对修改关闭 里氏转换原则：子类继承父类，单独调用完全可以运行 依赖倒转原则：引用一个对象 如果这个对象有底层类型，直接引用底层 结构隔离原则：每一个接口应该是一中角色 单例模式 一个类只有一个实例 有就返回 没有就初始化 单例作为命名空间的提供者","text":"设计模式 让系统代码可重用 可扩展 可解耦 更容易 被理解 且保证代码的可靠性 原则 开闭原则：对扩展开发 对修改关闭 里氏转换原则：子类继承父类，单独调用完全可以运行 依赖倒转原则：引用一个对象 如果这个对象有底层类型，直接引用底层 结构隔离原则：每一个接口应该是一中角色 单例模式 一个类只有一个实例 有就返回 没有就初始化 单例作为命名空间的提供者 1234567891011121314151617181920212223var single = (function ()&#123; var unique; function init()&#123; //单例代码 //私有方法 变量 var privateVariable = 'something private'; return &#123; publicMethod: function() &#123; console.log('hello world') &#125;, publicVariable: 'test' &#125; &#125;; return &#123; getUnique: function() &#123; if(!unique)&#123; unique = init() &#125; return unique &#125; &#125; &#125;)(); 工厂模式 不同参数生成不同子类 switch type 配置文件 12345678910111213141516171819202122232425var Car = (function() &#123; var Car = function(model, year, miles)&#123; this.model = model; this.year = year; this.miles = miles; &#125;; return function(model, year, miles) &#123; return new Car(model, year, miles) &#125;&#125;)();var pageDmo = &#123;&#125;;pageDmo.Text = function() &#123; return 'this is text type'&#125;;pageDmo.Link = function() &#123; return 'this is link type'&#125;;pageDmo.Image = function() &#123; return 'this is image type'&#125;;pageDmo.factory = function(type) &#123; return new pageDmo[type]&#125;;var o = pageDmo.factory('Link'); //'this is link type' 代理模式 委托 代理 中间件 proxy 12345678910111213141516171819var Girl = function(name) &#123; this.name = name &#125;var Boy = function(girl) &#123; this.girl = girl this.sendGift = function(gift) &#123; alert('hi'+this.girl+', boy send you '+ gift); &#125;&#125;var Proxy = function(girl) &#123; this.girl = girl; this.sendGift = function(gift) &#123; (new Boy(girl).sendGift(gift)) &#125;&#125;;var proxy = new Proxy(girl('name'));proxy.sendGift('6666礼物') 观察者模式 订阅发布模式 publish/subscribe 一对多的关系 观察者订阅xx消息类型接受发布数据 发布消息xx类型和数据 执行观察者订阅 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 订阅者数组arr[]// sub订阅的时候 arr.push(&#123;token, func&#125;)//发布的时候循环数组执行 订阅者的回调函数//取消订阅通过tokenvar subpub = &#123;&#125;;(function(q) &#123; var topics= &#123;&#125;; //消息类型对象 下面存放对着订阅者数据 // &#123; // type: [ // &#123;token: 0, func: callback&#125; // ] // &#125; var subUid = -1; //发布方法 q.pub = function(topic, args) &#123; //发布消息类型和数据 if(!topics[topic])&#123; //如果没有这个订阅这个消息的return return false &#125; setTimeout(function() &#123; var subs = topics[topic], len = subs ? subs.length : 0; //有几个订阅者 while(len--)&#123; subs[len].func(topic, args) //执行订阅者的方法(消息类型，数据) &#125; &#125;, 0) return true; //发布成功 &#125;; q.sub = function(topic, callback) &#123; //订阅消息 消息处理函数 if(!topics[topic])&#123; //如果没有这个消息 topics[topic]= [] //新建立一个 &#125; var token = (++subUid).toString(); topics[topic].push(&#123; //topic消息类型下 有多个订阅者 订阅者的token不同 且唯一 token: token, func: callback &#125;) return token; //返回id 取消订阅用 &#125; q.unsub = function(token) &#123; //退订 遍历所有的订阅者 找到对应token删除 for(var m in topics)&#123; if(topics[m])&#123; //如果有订阅者 for(var i = 0, j = topics[m].length; i &lt; j; i++)&#123; if(topics[m][i].token == token)&#123; topics[m].splice(i, 1); //找到删除 return; //退出 &#125; &#125; &#125; &#125; &#125;&#125;)(subpub)","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://ic-.gihub.io/tags/js/"},{"name":"设计模式","slug":"设计模式","permalink":"https://ic-.gihub.io/tags/设计模式/"}]},{"title":"js 单元测试","slug":"test","date":"2017-03-27T08:07:05.000Z","updated":"2017-03-30T07:08:47.000Z","comments":true,"path":"2017/03/27/test/","link":"","permalink":"https://ic-.gihub.io/2017/03/27/test/","excerpt":"","text":"","categories":[{"name":"js","slug":"js","permalink":"https://ic-.gihub.io/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://ic-.gihub.io/tags/js/"},{"name":"test","slug":"test","permalink":"https://ic-.gihub.io/tags/test/"}]},{"title":"Array","slug":"Array","date":"2017-03-20T10:24:06.000Z","updated":"2017-03-30T07:08:47.000Z","comments":true,"path":"2017/03/20/Array/","link":"","permalink":"https://ic-.gihub.io/2017/03/20/Array/","excerpt":"Array创建数组的方法123var arr = new Array(3) //[undefined * 3]var arr = new Array(1,2,3) //[1,2,3]var arr = [1,2,3] 属性123arr.constructor //Arrayarr.length //numarr.__proto__","text":"Array创建数组的方法123var arr = new Array(3) //[undefined * 3]var arr = new Array(1,2,3) //[1,2,3]var arr = [1,2,3] 属性123arr.constructor //Arrayarr.length //numarr.__proto__ 方法123456789101112131415161718192021222324252627282930313233343536373839arr[n] = 'new ele'delete arr[0] //[undefied, 2,3]arr.push(add_end) //arr.length arr has change 尾部插入arr.unshift() //arr.length arr has change 头部插入arr.pop() //arr.length arr has change 尾部删除arr.shift() //arr.length arr has change 头部删除arr.slice(start, end) //new arr arr no change arr.slice(start) arr.slice(start, -end)// return delete ele_arr arr has changearr.splice(start, delete_length, add_element) arr.sort((x, y)=&gt;&#123; return x - y &gt; 0 return x - y &lt; 0 return x - y = 0&#125;)arr.reverse() arr.concat([])arr.join(',')arr.indexOf(ele, start)arr.lastIndexOf(ele)//迭代方法arr.every((item, index, arr) =&gt;&#123; //所以为true 就为true return true/false&#125;)arr.some((v, k, arr)=&gt;&#123;&#125;) //任意一项返回 true 为truearr.filter((item, index, arr)=&gt;&#123; //返回值为true的新数组&#125;)arr.forEach((v, k, arr) =&gt; &#123; //没有返回值&#125;)arr.map((v, k, arr) =&gt;&#123;&#125;&#125;) //new arr","categories":[{"name":"js","slug":"js","permalink":"https://ic-.gihub.io/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://ic-.gihub.io/tags/js/"},{"name":"array","slug":"array","permalink":"https://ic-.gihub.io/tags/array/"}]},{"title":"interview2","slug":"interview2","date":"2017-03-08T01:25:32.000Z","updated":"2017-03-30T07:08:47.000Z","comments":true,"path":"2017/03/08/interview2/","link":"","permalink":"https://ic-.gihub.io/2017/03/08/interview2/","excerpt":"1.ajax? 异步传输 创建个XMLHttpRequest对象 创建一个http请求 设置http响应参数变化的函数 发送http请求 获取异步返回结果 更新","text":"1.ajax? 异步传输 创建个XMLHttpRequest对象 创建一个http请求 设置http响应参数变化的函数 发送http请求 获取异步返回结果 更新 1234567891011121314151617181920funtion Ajax(url, fnSuc, fnFail) &#123; if(window.XMLHttpRequest)&#123; var oAjax = new XMLHttpRequest() &#125;else&#123; var oAjax = new ActiveObject('Microsoft.XMLHTTP'); &#125; oAjax.open('get', url, true); oAjax.send(); oAjax.onreadystatechange = function() &#123; if(oAjax.readyState == 4)&#123; if(oAjax.status &gt;= 200 &amp;&amp; oAjax.status &lt; 300 || oAjax.status == 304)&#123; fnSuc(oAjax.responseText) &#125;else&#123; fnFail() &#125; &#125; &#125;&#125; 2.ajax解决缓存问题 oAjax.setRequestHeader(‘If-modified-Since’, ‘0’) oAjax.setRequestHeader(‘Cache-control’, ‘no-cache’) url后加随机数 ‘t=’+Math.random() url后加时间戳 ‘nowTime=’+ new Date().getTime(); 3.同步和异步的区别？ 4.解决跨域问题?如何解决跨域问题 5.页面编码和请求资源的编码不一致？ 设置请求编码格式 6.模块化开发怎么做？ 样式模块化 基础reset variables mixin(flex ellipsis) font color bg spacing grid button iconfont loading animation border 页面单独样式+基础样式 ui组件模块化 公用组件模块化 基础网络 路由 开发环境 7.AMD 和 CMD? AMD 依赖一开始就写好 和node一致 更友好写 更清晰 CMD 可就近依赖 8.requirejs的核心？ 正则分析依赖 递归出所有依赖 检查是否有缓存 有缓存用缓存 执行回调 没有缓存 动态创建script 添加 监听script load 完成后 执行回调9.ECMAScript 的了解？ 新增很多功能 用到的 const let symbol 字符串模板 解构 展开 箭头函数 promise class module class12345678910111213141516171819class Point &#123; constructor(x, y)&#123; this.x = x; this.y = y; &#125; toString()&#123; return ('('+ thihs.x +':'+ this.y+')') &#125;&#125;class ColorPoint extends Point&#123; constructor(x, y, color) &#123; super(x, y); // 调用父类的constructor(x, y) this.color = color; &#125; toString() &#123; return this.color + ' ' + super.toString(); // 调用父类的toString() &#125;&#125; 使用新功能要用转码器 babel 10.异步加载JS的方式有哪些？ defer document.onload 执行顺序固定 async 异步 执行顺序不固定 动态创建 script 插入 11.document.write 和 innerHMLT? document.write 复写整个页面 innerHTML 复写局部 12.call apply? fn.call(obj, arg1, arg2, arg3, …) fn.apply(obj, [args]) 13.js的变量提升和作用域? 变量提升: 预解析 执行到后在复制 没有块级作用域 只有函数作用域 14.那些操作会照成内存泄露？ 应用程序占用内存 由于某些原因 内存不回收 回收机制 mark-and-sweep 回收机制检查全局变量 对象是激活状态 不被回收 非激活被回收 闭包 不回收 意外的全局对象 没有var 直接 this.variables = ‘11111’; 严格模式解决： ‘use strict’ 循环引用 react 在render 或者 componentDidUpDate 更新state chrome 可看内存泄露 timeline 15.JQuery的源码看过吗？能不能简单概况一下它的实现原理？ 看过 jquery 建立了一整套高效的选择器 选择器 sizzle 返回选择数组对象 每个方法内部 循环调用数组 执行完成后 又返回数组对象 实现链式调用 16.Zepto的点透问题如何解决？ 用tap时间 有npm包 17.mvc mvp mvvm?MVC，MVP 和 MVVM 的图示 18.前端路由？适用范围？ 优缺点？ 根据不同的url 显示不同的页面 内容 单页应用 其实路由做的好 大部分都可以适用 用户体验好 19.前端模板？ 快速展示view结合data 20.检测浏览器版本? navigator.userAgent 功能检测 21.What is a Polyfill? 在旧的浏览器上复制标准的Api的js补充 html5shiv Placeholder 22.事件冒泡 和事件捕获 addEventListener(fn, dom, true/false) true 捕获 - 外到内 false default 冒泡 - 内到外 先一路捕获下去，然后一路冒泡上来 123456789101112131415//div&gt;span div.addEventListener('click', function()&#123; //捕获 console.log(11111) &#125;, true); div.addEventListener('click', function()&#123; //冒泡 console.log(22222) &#125;, false); span.addEventListener('click', function()&#123; //捕获 console.log(33333) &#125;, true); span.addEventListener('click', function()&#123; //冒泡 console.log(44444) &#125;, false);// 11111 3333 4444 2222 1.原来公司工作流程是怎么样的，如何与其他人协作的？如何夸部门合作的？ 项目立会 产品会出原型 ui前端后端 过一下原型 看有没有什么问题 互相沟通下 了解业务流程后 前端技术选型 比较成熟的是 移动端 webpack + react + redux + nodejs pc端 nodejs + jquery+gulp+requirejs 看具体项目需求 服务端定开发接口 mock 平台 接口规范 项目部署平台 开发文档 sdk 公用模块依赖 ui设计稿 sketch svg 图标 iconfont 阿里 开发 本地用Mock/测试环境数据 开发文档 readme.md 联调 提测/bug修改 优化 按需加载 打包体积 合并请求 静态资源cdn 部署 自动化部署 node 内网地址访问 23.你遇到过比较难的技术问题是？你是如何解决的？ 代理-cookie 用anyproxy代理 设计模式设计模式 排序排序 httphttp","categories":[{"name":"面试","slug":"面试","permalink":"https://ic-.gihub.io/categories/面试/"}],"tags":[{"name":"interview","slug":"interview","permalink":"https://ic-.gihub.io/tags/interview/"}]},{"title":"interview","slug":"interview","date":"2017-03-08T01:15:32.000Z","updated":"2017-03-30T07:08:47.000Z","comments":true,"path":"2017/03/08/interview/","link":"","permalink":"https://ic-.gihub.io/2017/03/08/interview/","excerpt":"1.Doctype的作用？标准模式和兼容模式各有什么区别？ &lt;!Doctype&gt; 位于html文档的第一行 告诉浏览器以什么标准解析html文档 Doctype不存在或者格式不正确会导致文档以兼容模式呈现 标准模式：排版和js都以浏览器支持的最高标准运行 兼容模式：页面以宽松的向后兼容的方式显示， 模拟老浏览器的行为 防止页面无法访问。","text":"1.Doctype的作用？标准模式和兼容模式各有什么区别？ &lt;!Doctype&gt; 位于html文档的第一行 告诉浏览器以什么标准解析html文档 Doctype不存在或者格式不正确会导致文档以兼容模式呈现 标准模式：排版和js都以浏览器支持的最高标准运行 兼容模式：页面以宽松的向后兼容的方式显示， 模拟老浏览器的行为 防止页面无法访问。 HTML 为什么只要要写 &lt;!DOCTYPE html&gt;？ HTML5 不属于SGML集合 不需要对DTD进行引用 SGML 标准通用语言 是个大集合 DTD document type definition 但是需要 doctype 规范浏览器的行为 3.行内元素 块级元素 空元素 有哪些 行内元素： a b span i em strong img input select 块级元素： h1.. div p ul ol li dl dt dd 空元素： br hr img input link meta 4.样式导入link和@import的区别 link 属于html标签 除了加载css 还能定语 rel rss @import 是css定义的只能提供加载css 页面加载时候 link会同时加载 @import引用的css会等页面加载完成在加载 @import ie5 以上兼容 5.介绍下浏览器内核的理解 主要分成2部分：渲染引擎和js引擎 渲染引擎负责取得网页内容 整理 计算 渲染 js引擎负责解析执行js 6.常见浏览器内核 trident ie 360 搜狗 gecko ff moz webkit safari chrome 7.html5有哪些新特性，移除哪些元素，如何处理html5新标签浏览器兼容问题？ 新特性： canvas video audio localStorage sessionStorage 语义化标签： article section header footer menu nav 表单控件 data time email url search 移除的元素： basefont big center font s 支持html5新元素：document.createElement 或者用成熟的框架 8.HTML语义化理解 用正确的标签做正确的事情 有利于优化css代码 让页面结构清晰 便于浏览器解析 搜索引擎解析 有利于seo 爬虫会分析html标记定语权重 9.html离线存储怎么使用 用户没有连接网络的时候正常访问站点和应用， 用户连接后更新用户机器上的缓存 基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的缓存清单离线缓存资源 这资源就像cookie一样被存储下来。 读取index.manifest 10.cookie localStorage sessionStorage的区别 cookie 标识用户身份而存储在用户本地终端上的数据 同源http请求头都会携带 大小有限不能超过4k 在设置过期时间之前一直有效 localStorage 本地永久存储 不限制大小 sessionStorage 会话存储 浏览器关闭后自动删除 11.iframe 有哪些确定 iframe 会阻塞主页面的onload事件 搜索引擎无法解读这种页面 不利于seo iframe和主页面共享连接池（2，4，6）会影响页面的并行加载 解决：js 动态赋值 src 12.label有什么作用 可以设置用户选择label标签那个表单元素获取焦点 13.html关闭form自动autocomplete=off 14.实现浏览器内多个标签页直接通信 websocket localstorge s localstorge另外一个浏览器上下文里被添加，修改或删除 都会触发一个事件 通过监听事件实现通信 但是无痕下报错 15.websocket 如何兼容 flash socket 长轮询的XHR 16.页面可见性(visibilityState)用途 监听visibilityState 检测页面是否 可操作自动播放或暂停 17.如何在页面上实现一个原型的可点击区域 border-radius svg map+area 纯js实现计算 18.网页验证码干嘛的 防止恶意刷请求 19.标准盒模型和低版本ie盒子模型的区别 标准盒模型 width = width box-sizing=content-box的效果 ie盒模型 width = width+padding+border box-sizing=border-box的效果 20.css选择符有哪些 哪些属性可以继承 #id .classname p div+p div &gt; p div p div:after div:nth-child() a[rel=’external’] 可继承 font-size font-family color ul li dl dd dt 不可继承 border margin padding width height 21.css优先级 import &gt; 标签内部 &gt; 内部样式 &gt; 外部样式文件 !important &gt; id &gt; classname &gt; tag &gt; * 22.css3新增伪类 :first-of-type :last-of-type :one-of-type :after :before :enable :checked :disbaled 23.div如何居中 margin: 0 auto 水平居中 position:absolute; left:0; top: 0; bottom: 0; right: 0; width: 300px; height: 300px; position:relative; left: 50%; top: 50%; margin-left: -150px; margin-top: -150px; position:absolute; left: 50%; top: 50%; transform: translate(-50%, -50%) parentNode: display:flex; item-align: center; //垂直居中 justify-content:center //水平居中 24.display有哪些值 display: none display: block display: inline display: inline-block display: table display: inherit display: list-item 象块类型元素一样显示，并添加样式列表标记。 25.position static 默认 inherit 继承父 absolute 相对于设置了position不为static的父级定位 relative 相对于自身文档流位置 fixed 相对于可视区 ie不兼容 sticky (relative和fixed结合) 目标区域在屏幕中可见的时候 是relative效果 当目标超出滚动区域的时候 吸顶效果或底部固定效果 26.css3新特性 border-radius box-shadow text-shadow transform gradient 27.css3 flexbox 28.css创建三角形 border 隐藏另外三个边 29.常见浏览器兼容性 png24在ie6下显示背景，解决 png8 浏览器默认margin padding不同 reset ie6 双边距：float元素横行的margin产生双边距 解决 _display:inline hack \\9 //ie6,7,8 //ie6,7 _ //ie6 chrome 小于12px的字体 按照12px显示 解决 -webkit-text-size-adjust: none ie下获取元素属性可以直接获取 ff要用getAttribute 统一解决 getAttribute 超链接访问过后 hover样式不显示 l-v-h-a : a:link a:visited: a:hover a:active 30.为什么要初始化css 因为浏览器兼容问题， 不同浏览器对有些标签的默认值是不同的， 如果不做初始化 不同浏览器下表现会有差异 最简单的 *{margin: 0; padding: 0} 31.position跟display margin collapse overflow float 特性叠加 如果元素为display:那么元素不渲染，position float不起作用 如果维absolute fixed 那么float不起作用 float 元素脱离文档流 float absolute inline-block的元素 margin 不塌陷 32.css权重 相同权重 最后定义的样式会起作用 33.清除浮动 清除浮动 为了消除 浮动元素对布局产生的影响 浮动的元素 高度会塌陷 高度塌陷后面的内容不能正常显示 添加标签设置 clear:both 清除浮动 overflow: hidden/auto; *zoom: 1; :after clear:both 闭合浮动 其他的为了隐藏元素 zoom：1 触发IE hasLayout12.clearfix&#123;*zoom:1&#125; .clearfix:after&#123;clear:both; content:'', display:block; font-size:0; height: 0; visibility: hidden&#125; 34.外边距合并，塌陷 垂直方向 小margin回塌陷进入大margin 35.zoom:1清楚浮动的原理 清除浮动 触发 hasLayout Zoom ie 专有属性 设置检索元素的缩放比例 解决ie比较奇怪的bug 设置了zoom 会触发重新计算 宽高 发生重新渲染 36.移动端 媒体查询 @media(条件)and (条件){ 当前条件下使用的样式} 37.css预处理器 less 组内用的less sass sass功能会强大些 38.css优化，提高性能的方法 选择器的优化 样式顺序的优化 提取变量（颜色 字体大小 动画 等） 基础样式（margin padding flex clear等） ui组件 如果有统一的ui规范 做好基础规范 用统一的规范 保证视觉效果的一致性 使用构建工具 打包压缩 自动添加前缀 39.浏览器是怎么解析css的 从左往右 就近原则 40.网页中用奇数还是偶数字体 偶数 会好些 居中 如果有比例计算的话 41.margin 和padding的使用场景 margin是用来分隔元素与元素 padding分隔元素与内容的 有border 有background的时候 42.抽离样式模块怎么写，说出思路，有无实践经验？ 1.我们一般会用sass或者less先抽离出所有变量 如颜色 字体大小 主题风格 网站字体 为单独的文件 2.我们还会按属性 抽离出不同的 模块 如果 margin和padding border 公用ui模块 字体图标模块 3.当要用这些的模块的就@import 引入 字体图标可以一开始在main文件引入 43.元素竖向的百分比设定是相对于容器的高度吗? 不是 是宽度 44.伪类和伪元素 :before css3伪类 ::before css3伪元素 45.chrome记住密码后自动填充表单黄色背景1234567input:-webkit-autofill, textarea:-webkit-autofill, select:-webkit-autofill&#123; background-color: rgb(250, 255, 189); /* #FAFFBD; */ background-image: none; color: rgb(0, 0, 0)&#125; 46.line-height如何理解？ 撑开高度 单行可做居中 47.设置元素浮动后display的值？ display: blcok 48.chrome支持12px的字体？ 图片 最小使用12px的字体 设置-webkit-text-adjust: none chrome低版本 27以下有效 对中文无效 用transform 49.字体清晰变细？ -webkit-font-smoothing: antialiased; 50.手写动画执行时间？ requestAnimationFrame 60Hz 1000s/60 = 16.7ms 51.display:inline-block 会显示间隔？ 删除空格 font-size: 0 52.overflow: scroll时不能平滑滚动的问题怎么处理？ -webkit-overflow-scrolling: touch; 53.cookie隔离？ 静态资源放在主域名下 那么请求静态资源会带上cookie 浪费流量 cookie有域限制 因此不能跨域提交请求，所以使用非主要域名的时候 请求头中不会带有cookie 54.js数据类型 基本类型 undefined unll string number boolean 2015 新增symbol 创建后独一无二不可变 引用类型：堆（对象数组） 55.js内置对象 Object 所有对象的父对象 数据类型封装对象 Object Array Boolean Number String 其他对象： Function RegExp Math Date Error Anguments 56.js写法的基本规范？ 不要再一行声明多个变量 用===/!==比较 字面量 代替 new Array 不要使用全局变量 switch 必须带有 default 函数输出要一致 57.js原型链 当我们访问一个对象的属性方法的时候，如果对象不存在 那么它会顺着原型链一直往上找到 Object.prototype还没有的话返回null 对象实例没有prototype 只有指针指向构造函数的 prototype 构造函数的原型改变会影响所有的对象实例 58.继承 原型链继承 12345//新建实例 作为原型对象 效率会低一些function Parent()&#123;&#125;function Child()&#123;&#125;Child.prototype = new Parent()Child.prototype.constructor = Child 原型继承 123456//只是移动child.prototype 的指针指向Parent.prototype //缺点 修改Children.prototype 会影响 Parent.prototypefunction Parent()&#123;&#125;;function Child()&#123;&#125;;Child.prototype = Parent.prototypeChild.prototype.constructor = Child 临时构造函数 1234567891011121314function Parent()&#123;&#125;;function Child()&#123;&#125;;var F = function()&#123;&#125;;F.prototype = Parent.prototype;Child.prototype = new F();Child.prototype.constructor = Child;function extend(Parent, Child) &#123; var F = function()&#123;&#125; F.prototype = new Parent(); Child.prototype = F.prototype; Child.prototype.constructor = Child; Child.uber = Parent.prototype;&#125; 属性拷贝 12345678function extend2(Parnet, Child) &#123; var p = Parnet.prototype; var c = Child.prototype; for(var i in p)&#123; c[i] = p[i] &#125; c.uber = p&#125; 58.js作用域链？ 局部函数可以查看上层函数的细节 上层函数 无法直接访问局部函数细节 59.this的理解 有new的话 this指向new的对象实例 定时器的话都是window 事件this指向发生事件的对象 方法 this 指向调用方法的对象 其他 window 箭头函数 this 总是指向定义时所在的对象，而不是运行时所在的对象。 59.eval? 把字符串解析成js执行 60.window和document window 浏览器窗口 document html稳定对象 61.null 和 undefined null 空对象 undefined 变量没有初始化 62.阻止冒泡 ev.stopPropagation() event.cancelBubble = true 63.闭包？ 能读取其他函数的内部变量的函数 因为只有子函数才能读取 局部变量：所以也可以理解为定义在函数内部的函数 参数变量不会呗垃圾回收机制回收 64.use strict 严格运行模式 糟糕特性无法使用： with 不能赋值全局变量 代码块内不能声明函数 65.判断一个对象属于一个类 instanceof 66.new 操作符到底干嘛了？123var obj = &#123;&#125;obj.__prototype__ = Base.prototype;Base.call(obj) 67.js延迟加载？ defer和async defer html结构加载完成后才加载 async 异步加载加载完成后马上执行 动态创建DOM 按需加载","categories":[{"name":"面试","slug":"面试","permalink":"https://ic-.gihub.io/categories/面试/"}],"tags":[{"name":"interview","slug":"interview","permalink":"https://ic-.gihub.io/tags/interview/"}]},{"title":"webpack","slug":"webpack","date":"2017-02-27T07:35:48.000Z","updated":"2017-03-30T07:11:49.000Z","comments":true,"path":"2017/02/27/webpack/","link":"","permalink":"https://ic-.gihub.io/2017/02/27/webpack/","excerpt":"","text":"entry1234entry:&#123; \"index\": ['../xxx/index.js', hotMiddlewareScript], \"page1\": ['../xxx/page1/index.js', hotMiddlewareScript]&#125; output path: 文件打包存放路径 publicPath: 引用的文件路径 publicPath配合node服务端12345678910111213141516webpack.jsentry: &#123; indexA: ['./assets/javascripts/index.js']&#125;output: &#123; path: './public/dist', publicPath: '/assets/', filename: '/javascript/[name].js', libary&#125;// server/index.jsvar app = express()app.use('/assets', express.static(path.join(__dirname, '../public/dist')));// filename: /public/dist/javascript/indexA.js// publicPath: &lt;img src=\"/assets/logo.png\" /&gt;","categories":[{"name":"工具","slug":"工具","permalink":"https://ic-.gihub.io/categories/工具/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://ic-.gihub.io/tags/webpack/"}]},{"title":"express","slug":"express","date":"2017-02-22T03:45:30.000Z","updated":"2017-02-22T04:07:29.000Z","comments":true,"path":"2017/02/22/express/","link":"","permalink":"https://ic-.gihub.io/2017/02/22/express/","excerpt":"expressexpress 中文API 快速生成应用骨架12npm install express-generator -gexpress myapp","text":"expressexpress 中文API 快速生成应用骨架12npm install express-generator -gexpress myapp Api入口12var express = require(&apos;express&apos;)var app = express() express.static 是 Express 内置的唯一一个中间件,负责托管 Express 应用内的静态资源。1app.use([&apos;/path&apos;], express.static(&apos;public&apos;, [options])) Application处理请求1234app.get('/', function(req, res)&#123; res.send('hello world');&#125;);app.listen(3000); app.local.variables 类似全局变量 app.local.title = ‘my app’ app.local.strftime = require(“strftime”)app.mountpathapp.set(name, value)app.get(name)123app.set('title', 'my site')app.get('title')//=&gt;my site app.enable(name) //set name = trueapp.disable(name) //set name = falseapp.enabled(name) name 是否启用12345app.enabled('trust proxy')//=&gt; falseapp.enable('trust proxy')app.enabled('trust proxy')//=&gt; true app.disbaled(name) name 是否禁用12345app.disabled('trust proxy')//=&gt; trueapp.enable('trust proxy')app.disabled('trust proxy')//=&gt; false app.configure([env], callback) 当env和 app.get(‘env’) 匹配（即使 process.env.NODE_ENV）执行callback12345678910111213141516171819202122//所有环境app.configure(function()&#123; app.set('title', 'My Application')&#125;)//开发环境app.configure('development',function()&#123; app.set('db uri', 'localhost/dev')&#125;)//生产环境app.configure('production', function()&#123; app.set('db uri', 'n.n.n.n/prop')&#125;)// 所有环境app.set('title', 'My Application');// 只用于开发环境if ('development' == app.get('env')) &#123; app.set('db uri', 'localhost/dev');&#125;// 只用于生产环境if ('production' == app.get('env')) &#123; app.set('db uri', 'n.n.n.n/prod');&#125; app.use([path], function) 中间键 path默认为 ‘/‘123456789var express = require('express')var app = express()//一个简单的loggerapp.use(function(req, res, next)&#123; console.log('%s %s', req.methond, req.url) next()&#125;)//响应app.use('/static', express.static(__dirname+'/public')) settings 改变 express 的行为 例：app.set(‘trust proxy’, ‘loopback’) env trust proxy …. app.engine(ext, callback) 注册模板引擎 ext(扩展名) callback处理对应的模板 app.engine(‘jade’, require(‘jade’).__express) 缓存处理 jade 后缀的 jade 模板到 require 中123456789101112app.engine('view engine', 'pug')//index.pughtml head title = title body h1 = message//appapp.get('/', function(req, res)&#123; res.render('index', &#123;title: 'Hey', message: 'Hello, here'&#125;)&#125;) app.params([name], callback) 路由参数处理逻辑 尝试加载信息id为(name的值) 如果没有传递给next(err) 123456789101112app.params('user', function(req, res, next, id)&#123; User.find(id, function(err, user)&#123; if(err)&#123; next(err) &#125;else if(user)&#123; req.user = user; next() &#125;else&#123; next(new Error('faild to load user')) &#125; &#125;)&#125;) 如果只传callback 那么就可以改变 app.params() API 123456789101112131415161718192021222324app.params(function(name, fn)&#123; if( fn installof RegExp)&#123; return function(req, res, next, val)&#123; var captures if(capture = fn.exec(String(val)))&#123; req.params[name] = captures next() &#125;else&#123; next('route') &#125; &#125; &#125;&#125;)app.params('id', /\\d+$/)app.get('/user/:id', function(req, res)&#123; res.send('user'+req.params.id))&#125;)app.params('range', /^(\\w+)\\.\\.(\\w+)?$/)app.get('/range/:range', function(req, res)&#123; var range = req.params.range; res.send('from'+range[1]+'to'+range[2])&#125;)","categories":[{"name":"node","slug":"node","permalink":"https://ic-.gihub.io/categories/node/"}],"tags":[{"name":"node","slug":"node","permalink":"https://ic-.gihub.io/tags/node/"},{"name":"express","slug":"express","permalink":"https://ic-.gihub.io/tags/express/"}]},{"title":"wx小程序","slug":"wx","date":"2017-02-22T03:02:12.000Z","updated":"2017-02-22T03:35:48.000Z","comments":true,"path":"2017/02/22/wx/","link":"","permalink":"https://ic-.gihub.io/2017/02/22/wx/","excerpt":"Appid 获取121.申请账号2.找企业认证信息 文档wx小程序 文件结构123456789app.jsapp.jsonapp.wxsspages home 1. xx.js js 2. xx.json 配置信息 3. xx.wxss css 4. xx.wxml html","text":"Appid 获取121.申请账号2.找企业认证信息 文档wx小程序 文件结构123456789app.jsapp.jsonapp.wxsspages home 1. xx.js js 2. xx.json 配置信息 3. xx.wxss css 4. xx.wxml html 配置信息123456789app.json 1.pages 路由 required 2.windows 小程序的状态栏、导航条、标题、窗口背景色。 3.tabBar 设置底部 tab 的表现 4.networkTimeout 设置网络超时时间 5.debugpages home 1.home.json 逻辑层1.注册程序12345678app.js [once]App(&#123; onLunch:function()&#123;&#125;, onShow:function()&#123;&#125;, onHide:function()&#123;&#125;, onError:function()&#123;&#125;, any[any typeof]&#125;) 2.注册页面123456789101112131415pages/home/home.jsvar app = getApp(); //获取app实例Pages(&#123; data, onLoad, onReady, onShow, onHide, onUnload, onPullDownRefresh, onReachBottom, onShareAppMessage, any&#125;) setData(&#123;&#125;) //更新数据 3.页面生命周期12345678910111213141516onLoad: 页面加载 一个页面只会调用一次。 接收页面参数可以获取wx.navigateTo和wx.redirectTo及&lt;navigator/&gt;中的 query。onShow: 页面显示 每次打开页面都会调用一次。 onReady: 页面初次渲染完成 一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互。 对界面的设置如wx.setNavigationBarTitle请在onReady之后设置。详见生命周期onHide: 页面隐藏 当navigateTo或底部tab切换时调用。onUnload: 页面卸载 当redirectTo或navigateBack的时候调用。 4.页面路由1234wx.navigateTo()wx.redirectTo()wx.navigateBack()wx.switchTab() 5.模块化12module.export.sayHello = function()&#123;&#125;var sayHello = require('./sayHello.js') 6.API 视图层1.数据绑定123456789//1.属性在双引号内 \"\"//2.变量在双大括号内&#123;&#123;&#125;&#125;//3.关键字在双引号内 \"&#123;&#123;true/false&#125;&#125;\" \"false\":为字符串&lt;view&gt;&#123;&#123;message&#125;&#125;&lt;/view&gt;&lt;view id=\"item-&#123;&#123;id&#125;&#125;\" &gt;&lt;/view&gt;&lt;view wx:if=\"&#123;&#123;condition&#125;&#125;\"&gt;&lt;/view&gt;&lt;view checked=\"&#123;&#123;true/false&#125;&#125;\"&gt;&lt;/view&gt;&lt;view hidden=\"&#123;&#123;flag?true:false&#125;&#125;\"&gt;&lt;/view&gt; 2.条件渲染11.wx:if 惰性为false不渲染 hidden都渲染 3.列表渲染1231. for不提供wx:key报warming&lt;view wx:for=\"&#123;&#123;array&#125;&#125;\"&gt;&#123;&#123;index&#125;&#125;&#123;&#123;item.message&#125;&#125;&lt;/view&gt;&lt;view wx:for=\"&#123;&#123;array&#125;&#125;\" wx:for-index=\"idx\" wx:for-item=\"itemName\"&gt;&#123;&#123;idx&#125;&#125;:&#123;&#123;itemName.message&#125;&#125;&lt;/view&gt; 4.模板1234567891011121314151617// 1.定义模板&lt;template name=\"msgItem\"&gt; &lt;view&gt;&#123;&#123;index&#125;&#125;: &#123;&#123;msg&#125;&#125;&lt;/view&gt; &lt;view&gt;Time: &#123;&#123;time&#125;&#125;&lt;/view&gt;&lt;/template&gt;// 2.调用模板// 模板拥有自己的作用域，只能使用data传入的数据。Page(&#123; data: &#123; item: &#123; index: 0, msg: 'this is template', time: '2017-01-11' &#125; &#125;&#125;)&lt;template is=\"msgItem\" data=\"&#123;&#123;..item&#125;&#125;\"&gt;&lt;/template&gt; 5.事件12345678910111213141516171819202122232425261.冒泡事件和非冒泡事件 冒泡事件： touchstart touchmove touchcancel touchend tap longtap 非冒泡事件：剩下的都是2.事件绑定 bind+事件名称: bindTap 不会阻止事件冒泡 catch+事件名称: catchTap 会阻止事件冒泡3.事件对象 1.baseEvent 基础事件对象属性： - type - timeStamp 时间戳 - target 触发事件的组件的一些属性值集合 - currentTarget 当前组件的一些属性值集合 2.customEvent 自定义事件属性列表 - +detail 额外的信息 3.TouchEvent 触摸事件属性 - +touchs 触摸事件，当前停留在屏幕中的触摸点信息的数组 - +changeTouchs 触摸事件，当前变化的触摸点信息的数组 4.特殊事件： &lt;canvas/&gt; 中的触摸事件不可冒泡，所以没有 currentTarget。 &lt;view data-alpha-beta=\"1\" data-alphaBeta=\"2\" bindTap=\"bindViewTap\"&gt;Dataset test&lt;/view&gt; Page(&#123; bindViewTap: function(event)&#123; event.target.dataset.alphaBeta === 1 //-会转为驼峰 event.target.dataset.alphabeta === 2 //大写会转为小写 &#125; &#125;) 6.引用121.import 引入&lt;template&gt; 使用2.include 除&lt;template&gt;标签 整个代码引入 wxss1.尺长单位：rpx可以根据屏幕宽度进行自适应。2.样式倒入： @import “common.wxss”;3.内联样式： 4.选择器：.class #id element(所有的view组件) element,element（element, checkbox） ::after ::before5.全局样式与局部样式 app.wxss 全局 pages/xx/xx.wxss 局部样式","categories":[],"tags":[{"name":"wx小程序","slug":"wx小程序","permalink":"https://ic-.gihub.io/tags/wx小程序/"}]},{"title":"gulp","slug":"gulp","date":"2017-02-22T03:00:07.000Z","updated":"2017-03-30T07:12:09.000Z","comments":true,"path":"2017/02/22/gulp/","link":"","permalink":"https://ic-.gihub.io/2017/02/22/gulp/","excerpt":"","text":"gulp Autoprefixer : 处理浏览器前缀 browserslist //浏览器版本 sourceMap gulp-rev-orig 自动加时间戳 fuck","categories":[{"name":"工具","slug":"工具","permalink":"https://ic-.gihub.io/categories/工具/"}],"tags":[{"name":"gulp","slug":"gulp","permalink":"https://ic-.gihub.io/tags/gulp/"}]},{"title":"React","slug":"React","date":"2017-02-21T11:38:39.000Z","updated":"2017-03-21T07:03:30.000Z","comments":true,"path":"2017/02/21/React/","link":"","permalink":"https://ic-.gihub.io/2017/02/21/React/","excerpt":"组件生命周期 挂载：组件被插入DOM getInitialState() 初始化state componentWillMount() 即将被挂载 componentDidMount() 组件挂载 DOM操作在这里 更新： componentWillReciveProps(object nextProps) 挂载组件接收新的props shouldComponentUpdate(object nextProps, object nextState) 比较 nextPorps 和 this.props 比较 nextState 和 this.state 返回 false 的话不更新DOM componentWillUpdate(object nextProps, object nextState) 这里可以调用this.setState({name: value}) componentDidUpdate(object prevProps, object prevState) 组件更新之后 移除 componentWillUnmount() 组件移除和销毁之前，这边做清理工作，如定时器","text":"组件生命周期 挂载：组件被插入DOM getInitialState() 初始化state componentWillMount() 即将被挂载 componentDidMount() 组件挂载 DOM操作在这里 更新： componentWillReciveProps(object nextProps) 挂载组件接收新的props shouldComponentUpdate(object nextProps, object nextState) 比较 nextPorps 和 this.props 比较 nextState 和 this.state 返回 false 的话不更新DOM componentWillUpdate(object nextProps, object nextState) 这里可以调用this.setState({name: value}) componentDidUpdate(object prevProps, object prevState) 组件更新之后 移除 componentWillUnmount() 组件移除和销毁之前，这边做清理工作，如定时器 组件不可用ref, key关键字做为属性 ref， key 关键字 组件引用设置ref=”exampleRef” 父组件可引用 组件内部实现ref=”insetRef” 组件内部使用 this.props.children 路由下面所有的子路由包含的子节点 每个路由下都对应个页面 12345678910111213141516// root/index.js App入口&lt;div&gt; &lt;Header /&gt; &lt;Toast /&gt; &lt;Alert /&gt; &#123;this.props.children&#125; &lt;Footer /&gt;&lt;/div&gt;//or&#123;children &amp;&amp; React.cloneElement(children, &#123; key: location.pathname, showToast, //action loading, //action getJumpUrl&#125;)&#125; react-router 代码按需加载 webpack 配置 name chunk 指定的名字, 未指定默认分配 id 作为 name。 chunkhash:5 是文件的 hash 码，这里只使用前五位123456output:&#123; path: path.join(__dirname, &apos;../dist/assets&apos;, filename: &apos;app.js&apos; publicPath: defaultSetting.publicPath, chunkFileName: &apos;[name].[chunkhash:5].chunk.js&apos;&#125; 提出route path require.ensure(dependencies, callback, chunkName) es6写法中 module.exports 需要在cb后面加.default1234567891011121314151617const rootRoute = (store)=&gt;&#123; return &lt;Route&gt; &lt;Route path=\"/home\" getComponent=&#123;(nextState, cb) =&gt; &#123; require.ensure([], (require) =&gt; &#123; cb(null, require('./components/home')).default &#125;) &#125;&#125; /&gt; &lt;/Route&gt;&#125;ReactDom.render( &lt;Roter history=&#123;browserHistory&#125; routes = &#123;rootRoute&#125; /&gt;) reactredux 管理状态state树 action 带数据的动作 reducer 根据action更新state树re store 接收reducer和初始数据 关联 action 和 reducer 拆分reducer 对应应用分支 然后用combineReducers()合并store 会把当前的state树和action传递给reducer store.getState() store.dispatch(action) store.subscribe(listener) 123import &#123;createStore&#125; from 'redux'import rootReducer from './reducers'let stroe = createStore(rootReducer, window.__initData__) react-redux","categories":[{"name":"React","slug":"React","permalink":"https://ic-.gihub.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://ic-.gihub.io/tags/React/"}]},{"title":"CSS 笔记","slug":"CSS","date":"2017-02-21T08:59:27.000Z","updated":"2017-03-02T08:12:06.000Z","comments":true,"path":"2017/02/21/CSS/","link":"","permalink":"https://ic-.gihub.io/2017/02/21/CSS/","excerpt":"属性1.overflow-scrolling: touch 2.pointer-events: none 设置元素点击穿透 3.transform-origin 设置变换源","text":"属性1.overflow-scrolling: touch 2.pointer-events: none 设置元素点击穿透 3.transform-origin 设置变换源 多行文本溢出1.display: -webkit-box 将对象作为弹性伸缩盒子模型显示； 2.-webkit-line-clamp: 2; 私有属性限制行数 3.-webkit-box-orient 设置或检索伸缩盒对象的子元素的排列方式； 4.text-overflow: ellipsis 用省略号“…”隐藏超出范围的文本。 5.元素设置有padding的时候 会漏出 12345display: -webkit-box;overflow : hidden;text-overflow: ellipsis;-webkit-line-clamp: 2;-webkit-box-orient: vertical; -webkit-font-smoothingWindows系统上-webkit-font-smoothing属性不造成区别。iOS上，修改-webkit-font-smoothing属性，结果是：-webkit-font-smoothing: none: 无抗锯齿-webkit-font-smoothing: antialiased | subpixel-antialiased | default: 灰度平滑 单行文本溢出省略号123overflow: hidden;text-overflow: ellipsis;white-space: nowrap; Iconfont 字体图标居中问题原因：baseline偏上12345上边界（ascent）下边界（descent)bbox: bounding box bbox=&quot;0 -212 1026.5 896&quot; //有问题 bbox=&quot;-0.161291 -128 1707 900&quot; //优化后的 解决：在iconfont项目中编辑图标，保存后回自动调整基线 DPI/PPI DPI（dots per inch） css像素 设备独立像素 PPI（pixels per inch） 物理像素 一个屏幕下拥有的物理显示单元的个数 计算：PPI = √ w^2 + h^2 / 对角线长度 PPI 120-160 低密度 160-240 中密度 240-320 高密度 320+ 超高密度(Retina) DPR (device pixel ratio) 设备像素比 设备像素比 = 物理像素 / 设备独立像素 // 在某一方向上，x方向或者y方向 window.devicePixelRatio获取到当前设备的dpr。 -webkit-device-pixel-ratio，-webkit-min-device-pixel-ratio，-webkit-max-device-pixel-ratio进行媒体查询 例： iphone 6 dpi 375*667 dpr = 2 ppi = 375*2/667*21234567891011dpr = 2width: 2pxheight: 2px=&gt; dpi 2/2=&gt; ppi 2*2/2*2 //占用16个 dpr = 3 width: 2pxheight: 2px=&gt; dpi 2/2=&gt; ppi 2*3/2*3 //占用36个","categories":[{"name":"css","slug":"css","permalink":"https://ic-.gihub.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://ic-.gihub.io/tags/css/"}]},{"title":"npm","slug":"npm","date":"2017-02-21T08:55:36.000Z","updated":"2017-02-21T08:56:53.000Z","comments":true,"path":"2017/02/21/npm/","link":"","permalink":"https://ic-.gihub.io/2017/02/21/npm/","excerpt":"","text":"自己手动rm -rm /User/xxx/.npm下的 cache包 会导致 npm无法使用： ENOENT: no such file or directory, uv_cwd 解决：npm cache clean -f 强制清除","categories":[{"name":"工具","slug":"工具","permalink":"https://ic-.gihub.io/categories/工具/"}],"tags":[{"name":"npm","slug":"npm","permalink":"https://ic-.gihub.io/tags/npm/"}]},{"title":"gen-thunk-promise-co","slug":"gen-thunk-promise-co","date":"2017-02-20T12:37:12.000Z","updated":"2017-03-30T12:23:30.000Z","comments":true,"path":"2017/02/20/gen-thunk-promise-co/","link":"","permalink":"https://ic-.gihub.io/2017/02/20/gen-thunk-promise-co/","excerpt":"Generator 传统异步 代码各种嵌套 promise 只是改变了写法 然后最后用catch 捕获执行中的错误 1234567891011121314var readFile = require('fs-readFile-promise')readFile(fileA).then(function(data)&#123;console.log(data.toString())&#125;).then(function()&#123;return readFile(fileB)&#125;).then(function(data)&#123;console.log(data.toString())&#125;).catch(function(err)&#123;//&#125;)","text":"Generator 传统异步 代码各种嵌套 promise 只是改变了写法 然后最后用catch 捕获执行中的错误 1234567891011121314var readFile = require('fs-readFile-promise')readFile(fileA).then(function(data)&#123;console.log(data.toString())&#125;).then(function()&#123;return readFile(fileB)&#125;).then(function(data)&#123;console.log(data.toString())&#125;).catch(function(err)&#123;//&#125;) Generator ES6 中协程的体现 函数可以交出执行权（即暂停执行，又可以恢复执行） function name(){} 必须加上 号 整个 Generator 就是一个异步函数封装器 Gen 函数执行返回一个内部指针 函数体内外数据交互，处理错误机制 12345678910111213141516function* gen(x)&#123;var y = yield x + 2;return y&#125;var g = gen(1)g.next() // &#123;value: 3, done: false&#125;g.next() // &#123;value: undefined, done: true&#125;var g = g.gen(1)g.next() //&#123;value: 3, done: false&#125;g.next(2) //&#123;value:2, done: true&#125;var g = gen()g.next(2) // undefined+2 = NaN &#123;value:NaN, done: false&#125;g.next(3) // &#123;value: 3, done: true&#125; 1234567891011121314151617181920212223242526//内部处理错误，外部捕获function* gen(x)&#123;try&#123;var y = yield x + 2;&#125;catch(x)&#123;console.log(e)&#125;return y&#125;//异步var fetch = require('node-fetch')function* gen()&#123;var url = 'https://api.github.com/users/github';var result = yield fetch(url);console.log(result.bio)&#125;var g = gen();var result = g.next(); //执行fetch &#123;value: data, done: true&#125;result.value.then(function(data)&#123;return data.json()&#125;).then(function(data)&#123;g.next(data)&#125;) Thunk 传名调用 call by name 即只有在用的时候求值 用函数作为参数传入，调用的时候执行函数实现 thunk 函数的含义 实现将参数放到一个零时的函数，然后把这个临时函数传入函数内，这个临时函数就是Thunk 1234567891011121314function f(m)&#123;return m*2&#125;f(x+5)//等同于var thunk = function()&#123;return x+5&#125;function f(thunk)&#123;return thunk()*2&#125; Javascript语言的thunk函数 Thunk 函数替换的是多参数函数 将其替换成单参数的版本，且只接受回调函数作为参数 任意函数只要有回调函数都能写成Thunk函数的形式 生产环境转行 thunkify 123456789101112131415161718192021222324252627//正常版本的readFile(多参数版本)fs.readFile(filename, callback)//Thunk 版本的 readFile(单参数)var readFileThunk = Thunk(fileName);readFileThunk(callback)var Thunk = function(filename)&#123;return function(callback)&#123;return fs.readFile(filename, callback)&#125;&#125;// Thunk函数转换器var Thunk = function(fn)&#123;return function()&#123;var args = Array.prototype.slice.call(arguments);return function(callback)&#123;args.push(callback)return fn.apply(this,args)&#125;&#125;&#125;var readFileThunk = Thunk(fs.readFile);readFileThunk(filename)(callback) Generator 函数的流程管理 1234567891011121314151617181920212223var fs = require('fs')var thunkify = require('thunkify')var readFile = thunkify(fs.readFile)var gen = function* ()&#123;var r1 = yield readFile('/etc/fstab');console.log(r1.toString())var r2 = yield readFile('/etc/shells')console.log(r2.toString())&#125;var g = gen()var r1 = g.next()r1.value(function(err, data)&#123;if(err)throw errvar r2 = g.next(data) //把读取的data 往后传r2.value(function(err, data)&#123;if(err) throw errg.next(data)&#125;)&#125;) Thunk 函数的自动流程管理 1234567891011121314151617181920function run(fn)&#123;var gen = fn()function next(err, data)&#123;var result = gen.next(data)if(result.done)returnresult.value(next)&#125;next()&#125;var gen = function* ()&#123;var f1 = yield readFile('fileA');var f2 = yield readFile('fileB')var f3 = yield readFile('fileC')&#125;run(gen)","categories":[{"name":"js","slug":"js","permalink":"https://ic-.gihub.io/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://ic-.gihub.io/tags/js/"},{"name":"promise","slug":"promise","permalink":"https://ic-.gihub.io/tags/promise/"}]},{"title":"ES6","slug":"ES6","date":"2017-02-20T12:22:07.000Z","updated":"2017-03-30T07:10:18.000Z","comments":true,"path":"2017/02/20/ES6/","link":"","permalink":"https://ic-.gihub.io/2017/02/20/ES6/","excerpt":"ES6Let &amp; Const123456789101112131415161718192021/*1.没有预加载 变量提升2.块级作用域中 \b如果有声明变量，那么在声明之前不能使用\\(暂时性死区\\)3.不允许重复声明4.块级作用域5.允许块级作用域中声明函数 大括号 必须6.const 声明常量 let 声明变量7.顶层变量 不再window下*/function f1() &#123; let n = 5; if (true) &#123; let n = 10; &#125; console.log(n); // 5&#125;if(true)&#123; function f() &#123;&#125;&#125;let x = 1;window.x //undefined","text":"ES6Let &amp; Const123456789101112131415161718192021/*1.没有预加载 变量提升2.块级作用域中 \b如果有声明变量，那么在声明之前不能使用\\(暂时性死区\\)3.不允许重复声明4.块级作用域5.允许块级作用域中声明函数 大括号 必须6.const 声明常量 let 声明变量7.顶层变量 不再window下*/function f1() &#123; let n = 5; if (true) &#123; let n = 10; &#125; console.log(n); // 5&#125;if(true)&#123; function f() &#123;&#125;&#125;let x = 1;window.x //undefined 变量的解构：123456789101112131415按照一定的模式，从数组和对象中提取值，对变量进行赋值如果解构不成功等于undefined适用于 var let const数组按顺序对象按key值对象解构中模式不会被赋值 （即： let &#123;a: &#123;b: c&#125;&#125; = obj 中的a,b）数组 字符串 的length 可以用不要再模式中使用圆括号 数组解构123456789101112131415161718//匹配模式：var [a, b, c] = [1, 2, 3]a //1b //2c //3let [, ,third] = ['foo', 'bar', 'baz']third //'baz'let [head, ...tail] = [1,2,3,4]head //1tail //[2,3,4]//默认值：var [x= 1] = [undefined]x //1var [x = 1] = [null]x //null 对象解构123456789101112131415var &#123;foo, bar&#125; = &#123;foo: 'aaa', bar: 'bbb'&#125;foo //aaabar //bbblet obj = &#123;first: 'hello', last: 'world'&#125;let &#123;first: f, last: l&#125; = objf //hellol //worldfirst //error//默认值：var &#123;x = 3&#125; = &#123;&#125;x //3let &#123;log, sin, cos&#125; = Math 字符串解构12345678const &#123;a,b,c&#125; = 'edf'a //eb //dc //f//使用length 属性let &#123;length: len&#125; = 'hello'len //5 数值和布尔值123456let &#123;toString: s&#125; = 123;s // function toString()&#123;&#125;s ==== Number.prototype.toString //truelet &#123;toString: s&#125; = true;s === Boolean.prototype.toString //true 函数参数的解构赋值1234567891011121314function add([x,y])&#123;return x+ y;&#125;add([1,2]) //3// 获取键名for (let [key] of map) &#123;// ...&#125;// 获取键值for (let [,value] of map) &#123;// ...&#125; 字符串扩展1234567891.字符串模板2.字符串遍历 for..of3.at4.includes5.startsWith6.endsWith7.repeat 重复n次返回新字符串8.padStart 头部补全9.padEnd 正则扩展1231.RegExp构造函数new RegExp(/abc/ig, 'i').flags //覆盖2.字符串正则方法 match replace split search 全部指向正则 数值扩展12345671.Number.isFinite() Number.isNaN() Number.isInteger() //判断是否是整数 2.Number.parseInt() Number.parseFloat()3.Number.EPSILON 极小常量4.Number.isSafeInteger()5.Math.trunc()返回整数部分6.Math.sign() //-1 负数 +1 正数 0: 07.Math.cbrt() //立方根 数组扩展11.Array.from() //类数组 可遍历对象 转换为数组","categories":[{"name":"js","slug":"js","permalink":"https://ic-.gihub.io/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://ic-.gihub.io/tags/js/"},{"name":"ES6","slug":"ES6","permalink":"https://ic-.gihub.io/tags/ES6/"}]},{"title":"git","slug":"git","date":"2017-02-20T12:09:26.000Z","updated":"2017-03-30T12:20:49.000Z","comments":true,"path":"2017/02/20/git/","link":"","permalink":"https://ic-.gihub.io/2017/02/20/git/","excerpt":"Git git 命令大全 git –help git init git add readme.md git commit -m ‘readme.md’ git status git branch git branch dev git checkout dev git checkout master git merge dev git merge –no-ff -m “merge name-1 to name” branch git branch -d dev","text":"Git git 命令大全 git –help git init git add readme.md git commit -m ‘readme.md’ git status git branch git branch dev git checkout dev git checkout master git merge dev git merge –no-ff -m “merge name-1 to name” branch git branch -d dev clone git clone xxxx.git newfilename log git log git log -1 git log -5 git reflog remote 远程仓库 git remote add origin git@github.com:ic-/code 报错的话 ： git remote rm origin git push -u origin master //首次 git remote -v 远端仓库实际链接 git remote rm 别名[alias] git remote add [alias] git@gitxxx.gitfetch 从远端仓库下载新分支与数据push pull 从远端仓库提取数据并尝试合并到当前分支 本地和远程有冲突的话： git pull origin master git push origin master git psuh origin master //默认 git push origin dev //推送某个分支 git push origin :dev //删除远程分支 git push origin -f 强制覆盖 Reset checkout revert reset checkout (指定文件或所有文件) revert 不能指定文件 git reset HEAD@{2}/git checkout hotfixbranch –soft 缓存区和工作目录都不会被改变 –mixed 默认选项。缓存区和你指定的提交同步，但工作目录不受影响 –hard 缓存区和工作目录都同步到你指定的提交 alias 配置别名 git config –global alias.st status // 用st 代替 status git st git config –global aliss.co checkout git co git config –global alias.ci commit git ci git config –global alias.br branch git br 查看别名： cat .git/config vim .git/config //[alias] 修改 文件忘记忽略上传远程服务器问题解决：编辑 .gitignore 文件添加忽略git rm -r –cached .git add .git commit -m ‘repush’git push gitlab master 代码分支有问题问题：基础框架最新版本有问题，不知道的情况下提交了gitlab解决： - 方法1： - 获取gitlab owner权限 - 本地master分支代码reset到正确节点 - git push -f 强制覆盖 - 方法2： - 本地拉个dev分支 分支代码reset到正确节点 备用 - git 删除master 代码 提交远程 - git merge dev - merge 代码没过来。。 - 用了拷贝 - git push 到远程","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://ic-.gihub.io/tags/git/"}]},{"title":"http","slug":"http","date":"2017-02-20T10:52:24.000Z","updated":"2017-04-05T07:20:02.000Z","comments":true,"path":"2017/02/20/http/","link":"","permalink":"https://ic-.gihub.io/2017/02/20/http/","excerpt":"TCP/IP 协议族 应用层 决定了向用户提供应用服务时通信的活动 FTP: 文件传输 DNS: 域名系统 HTTP: http协议请求 通信 传输层 提供2台计算机直接的数据传输 TCP: 传输控制协议 UDP: 用户数据协议 网络层 处理网络上流动的数据包 在众多的选项内选择一条传输路线 IP协议：负责传输 是无状态的 传输成功与否在TCP协议中确认 链路层 处理网络的硬件部分 网卡 光纤","text":"TCP/IP 协议族 应用层 决定了向用户提供应用服务时通信的活动 FTP: 文件传输 DNS: 域名系统 HTTP: http协议请求 通信 传输层 提供2台计算机直接的数据传输 TCP: 传输控制协议 UDP: 用户数据协议 网络层 处理网络上流动的数据包 在众多的选项内选择一条传输路线 IP协议：负责传输 是无状态的 传输成功与否在TCP协议中确认 链路层 处理网络的硬件部分 网卡 光纤 TCP协议 传输协议 基于字节流的传输通信协议 应用层之下 IP层之上 应用层 》TCP 》IP 建立一个TCP链接 客户端和服务端要三次握手 SYN: synchronize ACK: acknowledgement client -&gt; SYN标志的数据包 -&gt; server server -&gt; SYN/ACK确认信息 -&gt; client client -&gt; ACK的数据包 -&gt; server ip协议 IP协议规定了数据传输时的基本单元和格式 传输包装方式和大小 IP协议还定义了数据包的递交办法和路由选择 传输方法和路线 DNS 应用层 浏览器中的URL通过DNS解析成IP DNS 服务器是集群是分层级的，没有任何一个单一的 DNS 服务器是中包含所有服务器 如果一个服务器没着到，会沿着节点一层一层往上找 每一个请求都是独立的无状态的 HTTP 应用层HTTP 通信 客户端在应用层（HTTP）访问URL 在传输层（TCP）把应用层的接受到的数据（HTTP报文请求），进行分割 并且打上标记（SYN ACK）转发给网络层 网络层（IP）增加作为通信的目的地的MAC地址后发给链路层 HTTP 请求 和响应request请求报文12方法 URL/URI 协议版本GET /search.html HTTP/1.1 响应报文12协议版本 状态码 描述HTTP/1.1 200 ok 请求响应头 通用头域 General 请求头 Request Headers 响应头 Response Headers 请求参数 Request PayLoad/Request body 返回结果 请求 Method GET 从服务器向客户端发送命名资源 POST 将客户端数据发送到一个服务器网关应用程序 OPTIONS 查询针对请求URI指定的资源支持的方法。 DELETE 从服务器中删除命名资源 PUT 将来自客户端的数据存储到一个命名的服务器资源中去 HEAD 仅发送命名资源响应中的 HTTP 首部 CONNECT 方法要求在代理服务器通信时建立隧道，实现隧道协议进行TCP通信。 TRACE 方法是让WEB服务器端将之前的请求通信环回给客户端的方法。 状态码 1XX 信息状态码 接受的请求正在处理 2XX 成功状态吗 请求正常处理完毕 3XX 重定向状态码 需要进行附加操作以完成请求 4XX 客户端错误状态码 服务器无法处理请求 5XX 服务器错误状态码 服务器处理请求出错 200 OK：请求正常处理。 204 No Content：请求正常处理，但没有资源可返回。 206 Partial Content： 客户端进行了范围请求，服务器成功执行这部分GET请求。 301 Moved Permanently： 永久性重定向，表明该资源已被分配了新的URI。 302 Found： 临时性重定向，表明该资源暂时被分配了新的URI。 303 See Other：表明请求的资源存在另一个URI，明确要求客户端采用GET方法重定向请求资源。 304 Not Modified : 未改变，使用缓存 400 Bad Request：请求报文中存在语法错误，需修改请求内容后再次发送。 401 Unauthorized*：请求需包含通过HTTP认证（BASIC认证、DIGEST认证等）的认证信息，浏览器初次接收401响应会弹出认证窗口。若之前已进行过一次请求，则表示用户认证失败。 403 Forbidden：请求资源的访问被服务器拒绝。服务器端没有必要给出拒绝的详细理由，不过也可以在响应主体部分对原因进行描述。未获得文件系统的访问授权（比如在IIS上部署网站时默认不能通过浏览器访问文件）、访问权限出现问题（比如从未授权的发送源IP地址试图访问）都有可能返回403响应。 404 Not Found：服务器无法找到请求的资源（也可在服务器端拒绝访问且不想说明理由时使用）。 500 Internal Server Error：服务器端执行请求时发生内部错误。多为服务器端程序出现Bug。 503 Service Unavailable：服务器处于超负载或正在停机维护，暂时无法处理请求。 WEB 的结构组件 代理 位于客户端和服务端中间 对请求和响应进行过滤等操作 缓存 HTTP 仓库 使常用副本保存在离客户端更近的地方 网关 链接其他服务器的特殊 WEB 服务器 HTTP &lt;-(http)-&gt; HTTP/FTP 网关 &lt;-(FTP)-&gt; FTP 服务器 隧道 对 HTTP 通信报文进行盲转发的特殊代理。 Agent 代理 发起自动 HTTP 请求的半智能 Web 客户端。 一次url请求发生了什么 DNS解析 先缓存查找 -&gt; 有返回 本地服务器 -&gt; 根域名服务器 -&gt; 有返回 根域名服务器 -&gt; 顶级域名服务器 -&gt;有返回 顶级域名服务器 -&gt; 网址域名服务器 -&gt;有返回 拿到ip 缓存ip 拿到ip和服务器 建立TCP链接 三次握手 加入标识/识别标识 数据传输走IP协议 浏览器向服务器发送一条 http 请求报文 请求行 请求头 请求正文 服务器返回给浏览器一条 HTTP 响应报文 状态码 响应头 响应报文 状态码 浏览器接收HTML, CSS, JS 渲染页面 渲染引擎 HTML构建DOM CSS计算样式构建渲染 浏览器开始渲染 重排和重绘 js引擎 解析执行js 会阻塞 挂起渲染 浏览器下载资源不会阻塞","categories":[{"name":"http","slug":"http","permalink":"https://ic-.gihub.io/categories/http/"}],"tags":[{"name":"http","slug":"http","permalink":"https://ic-.gihub.io/tags/http/"}]},{"title":"scrollView","slug":"scrollView","date":"2017-02-20T10:39:33.000Z","updated":"2017-02-21T02:28:25.000Z","comments":true,"path":"2017/02/20/scrollView/","link":"","permalink":"https://ic-.gihub.io/2017/02/20/scrollView/","excerpt":"scrollIntoView Syntax event.target.scrollIntoView() document.getElementById(‘demo’).scrollIntoView()","text":"scrollIntoView Syntax event.target.scrollIntoView() document.getElementById(‘demo’).scrollIntoView() Parameters scrollIntoView() scrollIntoView(alignToTop) true //align to the top of the visible area false //align to buttom of the visible area scrollIntoView(scrollIntoViewOptions) scrollIntoViewOptions bool/object {behavior: “auto” | “instant” | “smooth”,block: “start” | “end”,} {block: “start”} === false {block: “end”} === true","categories":[{"name":"css","slug":"css","permalink":"https://ic-.gihub.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://ic-.gihub.io/tags/css/"},{"name":"scrollView","slug":"scrollView","permalink":"https://ic-.gihub.io/tags/scrollView/"}]},{"title":"browser","slug":"browser","date":"2017-02-17T02:25:32.000Z","updated":"2017-03-30T12:20:00.000Z","comments":true,"path":"2017/02/17/browser/","link":"","permalink":"https://ic-.gihub.io/2017/02/17/browser/","excerpt":"12345678910111213141516171819var browser = &#123; versions: function()&#123; let u = window.navigator.userAgent; return &#123; trident: u.indexOf('Trident') &gt; -1, //IE内核 presto: u.indexOf('Presto') &gt; -1, //opera内核 webKit: u.indexOf('AppleWebKit') &gt; -1, //苹果、谷歌内核 gecko: u.indexOf('Gecko') &gt; -1 &amp;&amp; u.indexOf('KHTML') == -1, //火狐内核 mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端 ios: !!u.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端 android: u.indexOf('Android') &gt; -1 || u.indexOf('Linux') &gt; -1, //android终端或者uc浏览器 iPhone: u.indexOf('iPhone') &gt; -1 || u.indexOf('Mac') &gt; -1, //是否为iPhone或者安卓QQ浏览器 iPad: u.indexOf('iPad') &gt; -1, //是否为iPad webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部 weixin: u.indexOf('MicroMessenger') == -1 //是否为微信浏览器 &#125; &#125;&#125;module.exports = browser","text":"12345678910111213141516171819var browser = &#123; versions: function()&#123; let u = window.navigator.userAgent; return &#123; trident: u.indexOf('Trident') &gt; -1, //IE内核 presto: u.indexOf('Presto') &gt; -1, //opera内核 webKit: u.indexOf('AppleWebKit') &gt; -1, //苹果、谷歌内核 gecko: u.indexOf('Gecko') &gt; -1 &amp;&amp; u.indexOf('KHTML') == -1, //火狐内核 mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端 ios: !!u.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端 android: u.indexOf('Android') &gt; -1 || u.indexOf('Linux') &gt; -1, //android终端或者uc浏览器 iPhone: u.indexOf('iPhone') &gt; -1 || u.indexOf('Mac') &gt; -1, //是否为iPhone或者安卓QQ浏览器 iPad: u.indexOf('iPad') &gt; -1, //是否为iPad webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部 weixin: u.indexOf('MicroMessenger') == -1 //是否为微信浏览器 &#125; &#125;&#125;module.exports = browser ``` jsvar browser = { versions: function(){ let u = window.navigator.userAgent; return { trident: u.indexOf(‘Trident’) &gt; -1, //IE内核 presto: u.indexOf(‘Presto’) &gt; -1, //opera内核 webKit: u.indexOf(‘AppleWebKit’) &gt; -1, //苹果、谷歌内核 gecko: u.indexOf(‘Gecko’) &gt; -1 &amp;&amp; u.indexOf(‘KHTML’) == -1, //火狐内核 mobile: !!u.match(/AppleWebKit.Mobile./), //是否为移动终端 ios: !!u.match(/(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端 android: u.indexOf(‘Android’) &gt; -1 || u.indexOf(‘Linux’) &gt; -1, //android终端或者uc浏览器 iPhone: u.indexOf(‘iPhone’) &gt; -1 || u.indexOf(‘Mac’) &gt; -1, //是否为iPhone或者安卓QQ浏览器 iPad: u.indexOf(‘iPad’) &gt; -1, //是否为iPad webApp: u.indexOf(‘Safari’) == -1, //是否为web应用程序，没有头部与底部 weixin: u.indexOf(‘MicroMessenger’) == -1 //是否为微信浏览器 } }} module.exports = browser var browser = { versions: function(){ let u = window.navigator.userAgent; return { trident: u.indexOf(‘Trident’) &gt; -1, //IE内核 presto: u.indexOf(‘Presto’) &gt; -1, //opera内核 webKit: u.indexOf(‘AppleWebKit’) &gt; -1, //苹果、谷歌内核 gecko: u.indexOf(‘Gecko’) &gt; -1 &amp;&amp; u.indexOf(‘KHTML’) == -1, //火狐内核 mobile: !!u.match(/AppleWebKit.Mobile./), //是否为移动终端 ios: !!u.match(/(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端 android: u.indexOf(‘Android’) &gt; -1 || u.indexOf(‘Linux’) &gt; -1, //android终端或者uc浏览器 iPhone: u.indexOf(‘iPhone’) &gt; -1 || u.indexOf(‘Mac’) &gt; -1, //是否为iPhone或者安卓QQ浏览器 iPad: u.indexOf(‘iPad’) &gt; -1, //是否为iPad webApp: u.indexOf(‘Safari’) == -1, //是否为web应用程序，没有头部与底部 weixin: u.indexOf(‘MicroMessenger’) == -1 //是否为微信浏览器 } } } module.exports = browser","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://ic-.gihub.io/tags/js/"},{"name":"browser","slug":"browser","permalink":"https://ic-.gihub.io/tags/browser/"}]},{"title":"ls","slug":"laoshi","date":"2017-02-01T05:11:15.000Z","updated":"2017-04-05T07:33:57.000Z","comments":true,"path":"2017/02/01/laoshi/","link":"","permalink":"https://ic-.gihub.io/2017/02/01/laoshi/","excerpt":"","text":"&lt;!–天秤座广州大学 英语专8广东省广州市番禺区南浦西一村西一小学10-15农历相识2.219.1号第一天当班主任 大姨妈 18号-24号喜欢 小王子 华农紫荆花桥 刘亦菲水仙 木棉 紫荆花答应的事情：天涯海角 北京 看雪 摩天轮 看樱花 去周杰伦演唱会 恐高 不喜欢吃西兰花 舍友 少琴 喜欢 老师初中同学 砖哥班搭 林小胖 对象 华工研究生 做水利的 - 喜欢体育老师 被拒绝 - 体育老师 -渣男 大学同学闺蜜 菲菲 喜欢 安以轩初中同学好朋友 胖子 湛江 会计师好朋友 中国移动高中同学重庆好朋友： 丽小锦日本好朋友凤霞 胡玉 想北漂的女老师 156要求175会 打篮球 慢节奏的生活奶娘是谁珊琦","categories":[],"tags":[{"name":"老师","slug":"老师","permalink":"https://ic-.gihub.io/tags/老师/"}]}]}